/*  Copyright 2007, ontoprise GmbH
*  This file is part of the halo-Extension.
*
*   The halo-Extension is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 3 of the License, or
*   (at your option) any later version.
*
*   The halo-Extension is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
* 
* @author Thomas Schweitzer
*/
var AdvancedAnnotation = Class.create();

/**
 * This class handles selections in the rendered wiki page. It loads the 
 * corresponding wiki text from the server and tries to match HTML and wiki text.
 * Annotations can be added to the wiki text and are highlighted in the rendered
 * page.
 */
AdvancedAnnotation.prototype = {

	/**
	 * Initializes an instance of this class.
	 */
	initialize: function() {
		// Selection information
		this.anchorNode = null;
		this.annotatedNode = null;
		this.annoOffset = null;
		this.annoSelection = null;
		this.selectedText = '';
		
		// The wiki text parser manages the wiki text and adds annotations 
		this.wikiTextParser = null;
		
		// Load the wiki text for the current page and store it in the parser.
		this.loadWikiText();
		
		// Array of wiki text offset anchors. 
		this.wtoAnchors = 0;
		
	},
	
	/**
	 * This method is called, when the mouse button is released. The current
	 * selection is retrieved and used as annotation.
	 */
	onMouseUp: function() {
		var annoSelection = this.getSel();
		if (annoSelection != '') {
			// store details of the selection
			this.selectedText = annoSelection.toString();
			//trim selection
			this.selectedText = this.selectedText.replace(/^\s*(.*)\s*$/,'$1');
			this.anchorNode = annoSelection.anchorNode;
//			this.annotatedNode = this.anchorNode.parentNode;
			this.annotatedNode = this.anchorNode;
			this.annoOffset = annoSelection.anchorOffset;
			
			this.performAnnotation();
		}
	},
	
	/**
	 * Tries to find the current selection in the wiki text. If successful, the
	 * corresponding wiki text is augmented with an annotation.
	 */
	performAnnotation: function() {
		var parentNode = this.annotatedNode.previousSibling;
		var allNodes = $('content').descendants();
		var anchor = null;
		var findAnchor = true;
		
		// Search for a wiki text offset anchor among previous siblings
		while (parentNode) {
			if (parentNode.tagName == 'A'
			    && $(parentNode).getAttribute('type') == "wikiTextOffset") {
				anchor = $(parentNode);
				findAnchor = false;
				break;
			} else {
				parentNode = parentNode.previousSibling;
			}
		}
		
		parentNode = this.annotatedNode.parentNode;
		// Find the anchor that precedes the parent node (if not already
		// found and check if the marked text has been generated by a 
		// template
		var currentTemplateName = "";
		for (var i = 0; i < allNodes.length; ++i) {
			var node = allNodes[i];
			if (node.match('a')) {
				var type = node.getAttribute('type');			
			    if (findAnchor && type == "wikiTextOffset") {
					anchor = node;
			    }
			    if (type == "template") {
			    	if (currentTemplateName.length > 0) {
			    		alert("Internal error: Nested templates");
			    	}
			    	currentTemplateName = node.getAttribute('tmplname');
			    } else if (type == "templateend") {
			    	currentTemplateName = '';
			    }
			}
			if (node == parentNode) {
				break;
			}
		}
		
		// Check if the marked text is part of a template
		if (currentTemplateName.length > 0) {
			msg = gLanguage.getMessage('WTP_NOT_IN_TEMPLATE');
			msg = msg.replace(/\$1/g, this.selectedText);
			
			alert(msg);
			alert("Name of template: "+ currentTemplateName);
			return;
		}
		
		if (anchor) {
			// find this and the next anchor in the array of stored anchors
			var anchorIdx = this.wtoAnchors.indexOf(anchor);
			if (anchorIdx >= 0) {
				var start = anchor.getAttribute('name')*1;
				var end = (anchorIdx+1 < this.wtoAnchors.length)
							? this.wtoAnchors[anchorIdx+1].getAttribute('name')*1
							: -1;
			alert("Searching between:"+start+","+end+":\n"+this.wikiTextParser.text.substring(start,end));
				var res = this.wikiTextParser.findText(this.selectedText, start, end);
				if (res != true) {
					alert(res+"\n"+this.wikiTextParser.text.substring(start,end));
				} else {

					var result = this.wikiTextParser.addAnnotation('[[annotation::'+this.selectedText+']]');
					alert("Added at: "+result.toString());
					if (result) {
						// update anchors
						var offset = result[2] - (result[1]-result[0]);
						for (var i = anchorIdx+1; i < this.wtoAnchors.length; i++) {
							var a = this.wtoAnchors[i];
							var val = a.getAttribute('name')*1+offset;
							a.setAttribute('name', val);
						}
						
						// mark selection as annotated
						var node = this.annotatedNode.parentNode;
						var origText = node.innerHTML;
						var newText = origText.replace(this.selectedText, '<span class="aam_new_anno_prop_highlight">'+this.selectedText+"</span>");
						node.innerHTML = newText;
						
						catToolBar.fillList(true);
						relToolBar.fillList(true);
					}
					
				}

			} else {
				alert("No corresponding wiki text found.");
			}
		}
	
	},
	
	/**
	 * Gets the current selection from the browser.
	 */
	getSel: function() {
		var txt = '';
		if (window.getSelection) {
			txt = window.getSelection();
		} else if (document.getSelection) {
			txt = document.getSelection();
		} else if (document.selection) {
			txt = document.selection.createRange().text;
		}
		return txt;
	},
	
	/**
	 * @public
	 * 
	 * Loads the current wiki text via an ajax call. The wiki text is stored in
	 * the wiki text parser <this.wikiTextParser>.
	 * 
	 */
	loadWikiText : function() {
		function ajaxResponseLoadWikiText(request) {
			if (request.status == 200) {
				// success => store wikitext
				this.wikiTextParser = new WikiTextParser(request.responseText);
				catToolBar.setWikiTextParser(this.wikiTextParser);
				relToolBar.setWikiTextParser(this.wikiTextParser);
				catToolBar.fillList(true);
				relToolBar.fillList(true);
			} else {
				this.wikiTextParser = null;
			}
		};
		
		sajax_do_call('smwfGetWikiText', 
		              [wgPageName], 
		              ajaxResponseLoadWikiText.bind(this));
		              
		              
	},

};// End of Class

AdvancedAnnotation.create = function() {
	if (wgAction == "annotate") {
		smwhgAdvancedAnnotation = new AdvancedAnnotation();
			new PeriodicalExecuter(function(pe) {
				var content = $('content');
				Event.observe(content, 'mouseup', 
				              smwhgAdvancedAnnotation.onMouseUp.bindAsEventListener(smwhgAdvancedAnnotation));
				pe.stop();
				
				// retrieve all anchors of type "wikiTextOffset"
				smwhgAdvancedAnnotation.wtoAnchors = $$('#content a[type="wikiTextOffset"]');
		}, 2);
	}
	
};

var smwhgAdvancedAnnotation = null;
Event.observe(window, 'load', AdvancedAnnotation.create());
