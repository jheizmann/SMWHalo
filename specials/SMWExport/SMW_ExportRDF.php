<?php
/*
 * Created on 20.09.2007
 *
 * Author: kai
 */

 if (!defined('MEDIAWIKI')) die();

global $IP, $smwgIP;
require_once( "$IP/includes/SpecialPage.php" );
require_once( "$smwgIP/specials/ExportRDF/SMW_SpecialOWLExport.php");

// replace SMW RDF-Export SpecialPage with advanced HALO RDF-Export SpecialPage.
SpecialPage::removePage('ExportRDF');
SpecialPage::addPage(new SpecialPage('ExportRDF','',true,'doSpecialExportRDF',false));
//smwfInitUserMessages();

function getPageAsRDF($page = '') {
	global $wgOut, $wgRequest, $wgUser, $smwgAllowRecursiveExport, $smwgExportBacklinks, $smwgExportAll;

	$recursive = 0;  //default, no recursion
	$backlinks = $smwgExportBacklinks; //default

	// check whether we already know what to export //

	if ($page=='') { //try to get GET parameter; simple way of calling the export
		$page = $wgRequest->getVal( 'page' );
	} else {
		//this is needed since MediaWiki 1.8, but it is wrong for 1.7
		$page = rawurldecode($page);
	}

	if ($page=='') { //try to get POST list; some settings are only available via POST
		$pageblob = $wgRequest->getText( 'pages' );
		if ('' != $pageblob) {
			$pages = explode( "\n", $pageblob );
		}
	} else {
		$pages = array($page);
	}

	if( isset($page) ) {  // export to RDF
		ob_start();

		// Only use rdf+xml mimetype if explicitly requested
		// TODO: should the see also links in the exported RDF then have this parameter as well?
		if ( $wgRequest->getVal( 'xmlmime' )=='rdf' ) {
			header( "Content-type: application/rdf+xml; charset=UTF-8" );
		} else {
			header( "Content-type: application/xml; charset=UTF-8" );
		}

		if ( $wgRequest->getText( 'postform' ) == 1 ) {
			$postform = true; //effect: assume "no" from missing parameters generated by checkboxes
		} else $postform = false;

		$rec = $wgRequest->getText( 'recursive' );
		if ('' == $rec) $rec = $wgRequest->getVal( 'recursive' );
		if ( ($rec == '1') && ($smwgAllowRecursiveExport || $wgUser->isAllowed('delete')) ) {
			$recursive = 1; //users may be allowed to switch it on
		}
		$bl = $wgRequest->getText( 'backlinks' );
		if ('' == $bl) $bl = $wgRequest->getVal( 'backlinks' );
		if (($bl == '1') && ($wgUser->isAllowed('delete'))) {
			$backlinks = true; //admins can always switch on backlinks
		} elseif ( ($bl == '0') || ( '' == $bl && $postform) ) {
			$backlinks = false; //everybody can explicitly switch off backlinks
		}
		$date = $wgRequest->getText( 'date' );
		if ('' == $date) $date = $wgRequest->getVal( 'date' );

		$exp = new ExportRDFHalo();
		if ('' != $date) $exp->setDate($date);
		return $exp->getPage($page,$recursive,$backlinks);
	}
}


/**
 * Data class for holding all (special) data needed to export an articles
 * subject. Keeps data needed to generate type and URIs, as well as other
 * special property values.
 */
class SMWExportTitleHalo extends OWLExport {
	//@TODO: some of those members can be made local

	// Values for special properties, see SMW_Settings.php for documentation.
	// Each value may be missing if not set or not relevant
	public $has_type = false;
	public $has_uri = false; // TODO not used right now
	public $ext_nsid = false;
	public $ext_section = false;
	// relevant title values, mandatory
	public $title;
	public $title_text;
	public $title_namespace;
	public $title_id;
	public $title_fragment;
	public $title_prefurl;
	public $title_dbkey;
	public $modifier = '';
	public $value; // the title as a datavalue
	// details about URIs for export
	public $ns_uri = false;
	public $short_uri;
	public $long_uri;
	public $label;
	// key for hashing
	public $hashkey;
	// flags for controlling export
	public $is_individual;
	public $exists;

	/**
	 * Initialise the data for a given article title object, using the
	 * provided DB handler.
	 */
	public function SMWExportTitleHalo($title, $export, $modifier = '') {
		$this->title = $title;
		$this->title_text = $title->getText();
		$this->title_id = $title->getArticleID();
		$this->title_namespace = $title->getNamespace();
		$this->title_fragment = $title->getFragment();
		$this->title_prefurl = $title->getPrefixedURL();
		$this->title_dbkey = $title->getDBKey();
		$this->value = 	SMWDataValueFactory::newTypeIDValue('_wpg', $title->getPrefixedText());
		$this->hashkey = $this->title_prefurl . ' ' . $modifier; // must agree with keys generated elsewhere in this code!
		$this->modifier = $modifier;
		if ($modifier != '') $modifier = '#' . $modifier;

		$this->is_individual = ( ($this->title_namespace !== SMW_NS_PROPERTY) && ($this->title_namespace !== NS_CATEGORY) );
		$this->exists = $title->exists();

		if ($this->exists) {
			if ($title->getNamespace() == SMW_NS_PROPERTY) {
				$a = $export->store->getSpecialValues( $title, SMW_SP_HAS_TYPE );
				if (count($a)>0) $this->has_type = $a[0];
			}
			$a = $export->store->getSpecialValues( $title, SMW_SP_EXT_BASEURI );
			if (count($a)>0) $this->ns_uri = $a[0];
			$a = $export->store->getSpecialValues( $title, SMW_SP_EXT_NSID );
			if (count($a)>0) $this->ext_nsid = $a[0];
			$a = $export->store->getSpecialValues( $title, SMW_SP_EXT_SECTION );
			if (count($a)>0) $this->ext_section = $a[0];
		}

		// Calculate URIs and label
		global $wgContLang;
		$ns_text = $wgContLang->getNsText($this->title_namespace);
		if ($ns_text!='') {
			$ns_text .= ':';
		}

		if ($this->ns_uri === false) { //no external URI
			$this->ns_uri = ExportRDFHalo::makeXMLExportId(urlencode(str_replace(' ', '_', $ns_text)));
			$baseXML = ExportRDFHalo::makeXMLExportId(urlencode(str_replace(' ', '_', $this->title_text . $modifier)));
			switch ($this->title_namespace) {
				case SMW_NS_PROPERTY:
					$xmlprefix = 'property:';
					$xmlent = '&property;';
					break;
				default:
					$xmlprefix = 'wiki:';
					$xmlent = '&wiki;';
					$baseXML = $this->ns_uri . $baseXML;
					$this->ns_uri = '';
					break;
			}
			$this->long_uri = $xmlent . $baseXML;
			if (in_array(mb_substr($baseXML,0,1), array('-','0','1','2','3','4','5','6','7','8','9'))) { // illegal as first char in XML
				$this->short_uri = 'wiki:' . $this->ns_uri . $baseXML;
			} else {
				$this->short_uri = $xmlprefix . $baseXML;
			}
		} else { // external URI known
			$this->long_uri = $this->ns_uri . $this->ext_section;
			$this->short_uri = $this->ext_nsid . ':' . $this->ext_section;
		}
		if ($this->is_individual) {
			$this->label = $ns_text . $this->title_text;
		} else {
			$this->label = $this->title_text;
		}
		//$this->label = $this->title_text; // we show the namespace prefixes in most specials in our wiki, so this should also be done by external (re)users (mak)
		//TODO: should we make an exception for schema elements (Category, Attriubte, ...) where the prefix is clear from the context? At least namespaces like User: seem to be essential for understanding.
		if ($this->modifier != '') $this->label .= " ($this->modifier)";
		$this->label = smwfXMLContentEncode($this->label);
	}
}

/**
 * Class for encapsulating the methods for RDF export.
 */
class ExportRDFHalo extends OWLExport {

	/**#@+
	 * @access private
	 */

	const MAX_CACHE_SIZE = 5000; // do not let cache arrays get larger than this
	const CACHE_BACKJUMP = 500;  // kill this many cached entries if limit is reached,
	                             // avoids too much array copying; <= MAX_CACHE_SIZE!

	/**
	 * An array that keeps track of the elements for which we still need to
	 * write auxilliary definitions.
	 */
	private $element_queue;

	/**
	 * An array that keeps track of the elements which have been exported already
	 */
	private $element_done;

	/**
	 * Date used to filter the export. If a page has not been changed since that
	 * date it will not be exported
	 */
	private $date;

	/**
	 * Array of additional namespaces (abbreviation => URI), flushed on
	 * closing the current namespace tag. Since we export RDF in a streamed
	 * way, it is not always possible to embed additional namespaces into
	 * the RDF-tag which might have been sent to the client already. But we
	 * wait with printing the current Description so that extra namespaces
	 * from this array can still be printed (note that you never know which
	 * extra namespaces you encounter during export).
	 */
	private $extra_namespaces;

	/**
	 * Array of namespaces that have been declared globally already. Contains
	 * entries of format 'namespace abbreviation' => true, assuming that the
	 * same abbreviation always refers to the same URI (i.e. you cannot import
	 * something as rdf:bla if you do not want rdf to be the standard
	 * namespace that is already given in every RDF export).
	 */
	private $global_namespaces;

	/**
	 * Array of references to the SWIVT schema. Will be added at the end of the
	 * export.
	 */
	private $schema_refs;

	/**
	 * Unprinted XML is composed from the strings $pre_ns_buffer and $post_ns_buffer.
	 * The split between the two is such that one can append additional namespace
	 * declarations to $pre_ns_buffer so that they affect all current elements. The
	 * buffers are flushed during output in order to achieve "streaming" RDF export
	 * for larger files.
	 */
	private $pre_ns_buffer;

	/**
	 * See documentation for OWLExport::pre_ns_buffer.
	 */
	private $post_ns_buffer;

	/**
	 * Boolean that is true as long as nothing was flushed yet. Indicates that
	 * extra namespaces can still become global.
	 */
	private $first_flush;

	/**
	 * Integer that counts down the number of objects we still process before
	 * doing the first flush. Aggregating some output before flushing is useful
	 * to get more namespaces global. Flushing will only happen if $delay_flush
	 * is 0.
	 */
	private $delay_flush;

	/**
	 * Constructor.
	 */
	public function __construct() {
		$this->element_queue = array();
		$this->element_done = array();
		$this->schema_refs = array();
		$this->date = '';
	}


	/* Functions for exporting RDF */

	protected function printHeader() {
		global $wgContLang;

		$this->pre_ns_buffer .=
			"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" .
			"<!DOCTYPE rdf:RDF[\n" .
			"\t<!ENTITY rdf '"   . SMWExporter::expandURI('&rdf;')   .  "'>\n" .
			"\t<!ENTITY rdfs '"  . SMWExporter::expandURI('&rdfs;')  .  "'>\n" .
			"\t<!ENTITY owl '"   . SMWExporter::expandURI('&owl;')   .  "'>\n" .
			"\t<!ENTITY swivt '" . SMWExporter::expandURI('&swivt;') .  "'>\n" .
			"\t<!ENTITY property '" . SMWExporter::expandURI('&property;') .  "/'>\n" .
			"\t<!ENTITY wikiurl '" . SMWExporter::expandURI('&wikiurl;') .  "'>\n" .
			// A note on "wiki": this namespace is crucial as a fallback when it would be illegal to start e.g. with a number. In this case, one can always use wiki:... followed by "_" and possibly some namespace, since _ is legal as a first character.
			"\t<!ENTITY wiki '"  . SMWExporter::expandURI('&wiki;') .  "'>\n" .
			"]>\n\n" .
			"<rdf:RDF\n" .
			"\txmlns:rdf=\"&rdf;\"\n" .
			"\txmlns:rdfs=\"&rdfs;\"\n" .
			"\txmlns:owl =\"&owl;\"\n" .
			"\txmlns:swivt=\"&swivt;\"\n" .
			"\txmlns:wiki=\"&wiki;\"\n" .
			"\txmlns:wikiurl=\"&wikiurl;\"\n" .
			"\txmlns:property=\"&property;\"";
		$this->global_namespaces = array('rdf'=>true, 'rdfs'=>true, 'owl'=>true, 'swivt'=>true, 'wiki'=>true, 'property'=>true, 'wikiurl'=>true);

		$this->post_ns_buffer .=
			">\n\t<!-- Ontology header -->\n" .
			"\t<owl:Ontology rdf:about=\"\">\n" .
			"\t\t<swivt:creationDate rdf:datatype=\"http://www.w3.org/2001/XMLSchema#dateTime\">" . date(DATE_W3C) . "</swivt:creationDate>\n" .
			"\t\t<owl:imports rdf:resource=\"http://semantic-mediawiki.org/swivt/1.0\" />\n" .
			"\t</owl:Ontology>\n" .
			"\t<!-- exported page data -->\n";
		$this->addSchemaRef( "page", "owl:AnnotationProperty" );
		$this->addSchemaRef( "creationDate", "owl:AnnotationProperty" );
		$this->addSchemaRef( "Subject", "owl:Class" );
	}

	/**
	 * Prints the footer. Prints also all open schema-references.
	 * No schema-references can be added after printing the footer.
	 */
	protected function printFooter() {
		$this->post_ns_buffer .= "\t<!-- References to the SWiVT Ontology, see http://semantic-mediawiki.org/swivt/ -->\n";
		foreach ($this->schema_refs as $name => $type ) {
			$this->post_ns_buffer .=
				"\t<$type rdf:about=\"&swivt;$name\">\n" .
				"\t\t<rdfs:isDefinedBy rdf:resource=\"http://semantic-mediawiki.org/swivt/1.0\"/>\n" .
				"\t</$type>\n";
		}
		$this->post_ns_buffer .= "\t<!-- Created by Semantic MediaWiki, http://semantic-mediawiki.org -->\n";
		$this->post_ns_buffer .= '</rdf:RDF>';
	}

	/**
	 * Serialise the given semantic data.
	 */
	protected function printExpData(/*SMWExpData*/ $data) {
		$type = $data->extractMainType()->getSubject()->getQName();
		if ('' == $this->pre_ns_buffer) { // start new ns block
			$this->pre_ns_buffer .= "\t<$type";
		} else {
			$this->post_ns_buffer .= "\t<$type";
		}
		if ( ($data->getSubject() instanceof SMWExpLiteral) || ($data->getSubject() instanceof SMWExpResource) ) {
			 $this->post_ns_buffer .= ' rdf:about="' . $data->getSubject()->getName() . '"';
		} // else: blank node
		$this->post_ns_buffer .= ">\n";

		foreach ($data->getProperties() as $property) {
			$this->queueElement($property);
			foreach ($data->getValues($property) as $value) {
				$this->post_ns_buffer .= "\t\t<" . $property->getQName();
				$this->addExtraNamespace($property->getNamespaceID(),$property->getNamespace());
				$object = $value->getSubject();
				if ($object instanceof SMWExpLiteral) {
					if ($object->getDatatype() != '') {
						$this->post_ns_buffer .= ' rdf:datatype="' . $object->getDatatype() . '"';
					}
					$this->post_ns_buffer .= '>' .
					     str_replace(array('&', '>', '<'), array('&amp;', '&gt;', '&lt;'), $object->getName()) .
					     '</' . $property->getQName() . ">\n";
				} else { // bnode or resource, may have subdescriptions
					if (count($value->getProperties()) > 0) {
						$this->post_ns_buffer .= ">\n";
						$this->printExpData($value);
						$this->post_ns_buffer .= "\t\t</" . $property->getQName() . ">\n";
					} else {
						if ($object instanceof SMWExpResource) {
							$this->post_ns_buffer .= ' rdf:resource="' . $object->getName() . '"';
							$this->queueElement($object); // queue only non-explicated resources
						}
						$this->post_ns_buffer .= "/>\n";
					}
				}
			}
		}
		$this->post_ns_buffer .= "\t</" . $type . ">\n";
	}

	/**
	 * Print the triples associated to a specific page, and references those needed.
	 * They get printed in the printFooter-function.
	 *
	 * @param SMWExportTitle $et The Exporttitle wrapping the page to be exported
	 * @param boolean $fullexport If all the triples of the page should be exported, or just
	 *                            a definition of the given title.
	 * $return nothing
	 */
	protected function printObject(/*SMWSmallTitle*/ $st, $fullexport=true, $backlinks = false) {
		if (array_key_exists($st->getHash(), $this->element_done)) return; // do not export twice

		$value = SMWDataValueFactory::newTypeIDValue('_wpg');
		$value->setValues($st->dbkey, $st->namespace);
		$title = $value->getTitle();
		if ( $this->date !== '' ) { // check date restriction if given
			$rev = Revision::getTimeStampFromID($title->getLatestRevID());
			if ($rev < $this->date) return;
		}

		if ($fullexport) {
			$filter = false;
		} else { // retrieve only some core special properties
			$filter = array(SMW_SP_HAS_URI, SMW_SP_HAS_TYPE, SMW_SP_EXT_BASEURI);
		}
		$data = SMWExporter::makeExportData(smwfGetStore()->getSemanticData($title, $filter), $st->modifier);

		$this->printExpData($data); // serialise
		$this->markAsDone($st);

		// possibly add backlinks
		if ( ($fullexport) && ($backlinks) ) {
			wfProfileIn("RDF::PrintPages::GetBacklinks");
			$inRels = smwfGetStore()->getInProperties($value);
			foreach ($inRels as $inRel) {
				$inSubs = smwfGetStore()->getPropertySubjects( $inRel, $value );
				foreach($inSubs as $inSub) {
					$stb = new SMWSmallTitle();
					$stb->dbkey = $inSub->getDBKey();
					$stb->namespace = $inSub->getNamespace();
					if (!array_key_exists($stb->getHash(), $this->element_done)) {
						$semdata = smwfGetStore()->getSemanticData($inSub, array(SMW_SP_HAS_URI, SMW_SP_HAS_TYPE, SMW_SP_EXT_BASEURI));
						$semdata->addPropertyObjectValue($inRel, $value);
						$data = SMWExporter::makeExportData($semdata);
						$this->printExpData($data);
					}
				}
			}
			if ( NS_CATEGORY === $title->getNamespace() ) { // also print elements of categories
				$instances = smwfGetStore()->getSpecialSubjects( SMW_SP_HAS_CATEGORY, $title );
				foreach($instances as $instance) {
					$stb = new SMWSmallTitle();
					$stb->dbkey = $instance->getDBKey();
					$stb->namespace = $instance->getNamespace();
					if (!array_key_exists($stb->getHash(), $this->element_done)) {
						$semdata = smwfGetStore()->getSemanticData($instance, array(SMW_SP_HAS_URI, SMW_SP_HAS_TYPE, SMW_SP_EXT_BASEURI));
						$semdata->addSpecialValue(SMW_SP_HAS_CATEGORY, $value);
						$data = SMWExporter::makeExportData($semdata);
						$this->printExpData($data);
					}
				}
			}
			wfProfileOut("RDF::PrintPages::GetBacklinks");
		}
	}

	/**
	 * Add an extra namespace that was encountered during output. The method
	 * checks whether the required namespace is available globally and adds
	 * it to the list of extra_namesapce otherwise.
	 */
	public function addExtraNamespace($nsshort,$nsuri) {
		if (!array_key_exists($nsshort,$this->global_namespaces)) {
			$this->extra_namespaces[$nsshort] = $nsuri;
		}
	}

	/**
	 * Adds a reference to the SWIVT schema. This will make sure that at the end of the page,
	 * all required schema references will be defined and point to the appropriate ontology.
	 *
	 * @param string $name The fragmend identifier of the entity to be referenced.
	 *                     The SWIVT namespace is added.
	 * @param string $type The type of the referenced identifier, i.e. is it an annotation
	 *                     property, an object property, a class, etc. Should be given as a QName
	 *                     (i.e. in the form "owl:Class", etc.)
	 */
	public function addSchemaRef( $name,  $type ) {
		if (!array_key_exists($name, $this->schema_refs))
			$this->schema_refs[$name] = $type;
	}

	/**
	 * Add a given SMWExpResource to the export queue if needed.
	 */
	public function queueElement($element) {
		if ( !($element instanceof SMWExpResource) ) return; // only Resources are queued
		$title = $element->getDataValue();
		if ($title instanceof SMWWikiPageValue) {
			$spt = new SMWSmallTitle();
			$title = $title->getTitle();
			$spt->dbkey = $title->getDBKey();
			$spt->namespace = $title->getNamespace();
			$spt->modifier = $element->getModifier();
			if ( !array_key_exists($spt->getHash(), $this->element_done) ) {
				$this->element_queue[$spt->getHash()] = $spt;
			}
		}
	}

	/**
	 * Mark an article as done while making sure that the cache used for this
	 * stays reasonably small. Input is given as an SMWExportArticle object.
	 */
	protected function markAsDone($st) {
		if ( count($this->element_done) >= OWLExport::MAX_CACHE_SIZE ) {
			$this->element_done = array_slice( $this->element_done,
										OWLExport::CACHE_BACKJUMP,
										OWLExport::MAX_CACHE_SIZE - OWLExport::CACHE_BACKJUMP,
										true );
		}
		$this->element_done[$st->getHash()] = $st; //mark title as done
		unset($this->element_queue[$st->getHash()]); //make sure it is not in the queue
	}

	/**
	 * This function checks whether some article fits into a given namespace restriction.
	 * FALSE means "no restriction," non-negative restictions require to check whether
	 * the given number equals the given namespace. A restriction of -1 requires the
	 * namespace to be different from Category:, Relation:, Attribute:, and Type:.
	 */
	static public function fitsNsRestriction($res, $ns) {
		if ($res === false) return true;
		if ($res >= 0) return ( $res == $ns );
		return ( ($res != NS_CATEGORY) && ($res != SMW_NS_PROPERTY) && ($res != SMW_NS_TYPE) );
	}

	public function getPage($page,$recursive,$backlinks) {
		wfProfileIn("RDF::PrintPages");

		$linkCache =& LinkCache::singleton();
		$this->pre_ns_buffer = '';
		$this->post_ns_buffer = '';
		$this->first_flush = true;
		$this->delay_flush = 10; //flush only after (fully) printing 11 objects
		$this->extra_namespaces = array();

		$this->printHeader(); // also inits global namespaces

		wfProfileIn("RDF::PrintPages::PrepareQueue");
		// transform pages into queued export titles
		$cur_queue = array();
		$title = Title::newFromText($page);
		if (NULL === $title) continue; //invalid title name given
		$st = new SMWSmallTitle();
		$st->dbkey = $title->getDBKey();
		$st->namespace = $title->getNamespace();
		$cur_queue[] = $st;

		wfProfileOut("RDF::PrintPages::PrepareQueue");

		while (count($cur_queue) > 0) {
			// first, print all selected pages
			foreach ( $cur_queue as $st) {
				wfProfileIn("RDF::PrintPages::PrintOne");
				$this->printObject($st, true, $backlinks);
				wfProfileOut("RDF::PrintPages::PrintOne");
				if ($this->delay_flush > 0) $this->delay_flush--;
			}
			// prepare array for next iteration
			$cur_queue = array();
			if (1 == $recursion) {
				$cur_queue = $this->element_queue + $cur_queue; // make sure the array is *dublicated* instead of copying its ref
				$this->element_queue = array();
			}
			$linkCache->clear();
		}

		// for pages not processed recursively, print at least basic declarations
		wfProfileIn("RDF::PrintPages::Auxilliary");
		$this->date = ''; // no date restriction for the rest!
		if (!empty($this->element_queue)) {
			if ( '' != $this->pre_ns_buffer ) {
				$this->post_ns_buffer .= "\t<!-- auxilliary definitions -->\n";
			} else {
				print "\t<!-- auxilliary definitions -->\n"; // just print this comment, so that later outputs still find the empty pre_ns_buffer!
			}
			while (!empty($this->element_queue)) {
				$st = array_pop($this->element_queue);
				$this->printObject($st,false,false);
			}
		}
		wfProfileOut("RDF::PrintPages::Auxilliary");
		$this->printFooter();
//		$this->flushBuffers(true);
		return $this->pre_ns_buffer . $this->post_ns_buffer;
	}

	// Converts the given value to the SI unit value based, and also
	// returns the name of the unit. Inputs are the value in the standard
	// unit (a float) and the conversion spec string from the corresponds
	// to SI special attribute.
	// This function is only needed for the SI unit export.
	private function convertToSI ($stdvalue, $conversionSpec) {
		$preNum = '';
		$num = null;  // This indicates error.
		$unit = '';
		$decseparator = wfMsgForContent('smw_decseparator');
		$kiloseparator = wfMsgForContent('smw_kiloseparator');

		// First, split off number from the rest.
		// Number is, e.g. -12,347,421.55e6
		// Note the separators might be a magic regexp value like '.', so have to escape them with backslash.
		// This rejects .1 , it needs a leading 0.
		// This rejects - 3, there can't be spaces in the number.
		$arr = preg_split('/([-+]?\d+(?:\\' . $kiloseparator . '\d+)*\\' . $decseparator . '?[\d]*(?:\s*[eE][-+]?\d+)?)[ ]*/', trim($conversionSpec), 2, PREG_SPLIT_DELIM_CAPTURE);

		$arrSiz = count($arr);
		if ($arrSiz >= 1) $preNum = $arr[0];
		if ($arrSiz >= 2) $num = $arr[1];
		if ($arrSiz >= 3) $unit = $arr[2];

		if ($num !== null) {
			// sscanf doesn't like commas or other than '.' for decimal point.
			$num = str_replace($kiloseparator, '', $num);
			if ($decseparator != '.') {
				$num = str_replace($decseparator, '.', $num);
			}
			// sscanf doesn't like space between number and exponent.
			// TODO: couldn't we just delete all ' '? -- mak
			$num = preg_replace('/\s*([eE][-+]?\d+)/', '$1', $num, 1);

			$extra = ''; // required, a failed sscanf leaves it untouched.
			// Run sscanf to convert the number string to an actual float.
			// This also strips any leading + (relevant for LIKE search).
			list($num, $extra) = sscanf($num, "%f%s");

			// junk after the number after parsing indicates syntax error
			// TODO: can this happen? Isn't all junk thrown into $unit anyway? -- mak
			if ($extra != '') {
				$num = null;	// back to error state
			}

			// Clean up leading space from unit, which should be common
			$unit = preg_replace('/^(?:&nbsp;|&thinsp;|\s)+/','', $unit);

			if (is_infinite($num)) {
				return array(0, $unit);
			}
			return array($stdvalue*$num, $unit);
		} else {
			return array(0, '');
		}
	}

}
?>
