<?php
/*
 * Created on 20.09.2007
 *
 * Author: Joerg
 */

if (!defined('MEDIAWIKI')) die();
 
global $IP, $smwgIP, $smwgHaloIP;

require_once ($smwgHaloIP . '/specials/SMWGardening/Bots/SMW_ExportOntologyBot.php');

function getPageAsRDF($page = '') {
	global $wgOut, $wgRequest, $wgUser, $smwgAllowRecursiveExport, $smwgExportBacklinks, $smwgExportAll;

	$recursive = 0;  //default, no recursion
	$backlinks = $smwgExportBacklinks; //default

	// check whether we already know what to export //

	if ($page=='') { //try to get GET parameter; simple way of calling the export
		$page = $wgRequest->getVal( 'page' );
	} else {
		//this is needed since MediaWiki 1.8, but it is wrong for 1.7
		$page = rawurldecode($page);
	}

	if ($page=='') { //try to get POST list; some settings are only available via POST
		$pageblob = $wgRequest->getText( 'pages' );
		if ('' != $pageblob) {
			$pages = explode( "\n", $pageblob );
		}
	} else {
		$pages = array($page);
	}

	if( isset($page) ) {  // export to RDF
		ob_start();

		// Only use rdf+xml mimetype if explicitly requested
		// TODO: should the see also links in the exported RDF then have this parameter as well?
		if ( $wgRequest->getVal( 'xmlmime' )=='rdf' ) {
			header( "Content-type: application/rdf+xml; charset=UTF-8" );
		} else {
			header( "Content-type: application/xml; charset=UTF-8" );
		}

		if ( $wgRequest->getText( 'postform' ) == 1 ) {
			$postform = true; //effect: assume "no" from missing parameters generated by checkboxes
		} else $postform = false;

		$rec = $wgRequest->getText( 'recursive' );
		if ('' == $rec) $rec = $wgRequest->getVal( 'recursive' );
		if ( ($rec == '1') && ($smwgAllowRecursiveExport || $wgUser->isAllowed('delete')) ) {
			$recursive = 1; //users may be allowed to switch it on
		}
		$bl = $wgRequest->getText( 'backlinks' );
		if ('' == $bl) $bl = $wgRequest->getVal( 'backlinks' );
		if (($bl == '1') && ($wgUser->isAllowed('delete'))) {
			$backlinks = true; //admins can always switch on backlinks
		} elseif ( ($bl == '0') || ( '' == $bl && $postform) ) {
			$backlinks = false; //everybody can explicitly switch off backlinks
		}
		$date = $wgRequest->getText( 'date' );
		if ('' == $date) $date = $wgRequest->getVal( 'date' );

		$exp = new ExportRDFHalo();
		return $exp->getPage($page);
	}
}


/**
 * Class for encapsulating the methods for RDF export.
 */
class ExportRDFHalo {
	
	private $LINE_FEED = "\n";
 	private $namespace = 'http://www.halowiki.org';
 	private $page;
 		
 	public function getPage($page) {
 		$this->page = Title::newFromText($page);
 		// fetch articleId
 		$this->page->getArticleId();
 		$pageexport = $this->writeHeader();
 		$pageexport .= $this->exportProperties();
 		$pageexport .= $this->exportCategories();
 		$pageexport .= $this->exportInstance();
 		$pageexport .= $this->writeFooter();
 		return $pageexport;
 	} 		

 	private function writeHeader() {
 		$header = '<!DOCTYPE owl ['.$this->LINE_FEED;
   		$header .=	'<!ENTITY xsd  "http://www.w3.org/2001/XMLSchema#" >'.$this->LINE_FEED;
   		$header .=	'<!ENTITY a  "'.$this->namespace.'#" >'.$this->LINE_FEED;
   		$header .=	'<!ENTITY prop  "'.$this->namespace.'/property#" >'.$this->LINE_FEED;
   		$header .=	'<!ENTITY cat  "'.$this->namespace.'/category#" > ]>'.$this->LINE_FEED;
		$header .=	'<rdf:RDF'.$this->LINE_FEED;
    	$header .=	'xmlns:a   ="&a;"'.$this->LINE_FEED;
    	$header .=	'xmlns:cat ="&cat;"'.$this->LINE_FEED;
		$header .=	'xmlns:prop ="&prop;"'.$this->LINE_FEED;				
    	$header .=	'xmlns:owl ="http://www.w3.org/2002/07/owl#"'.$this->LINE_FEED;
		$header .=	'xmlns:rdf ="http://www.w3.org/1999/02/22-rdf-syntax-ns#"'.$this->LINE_FEED;
		$header .=	'xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">'.$this->LINE_FEED;
		$header .=	'<owl:Ontology rdf:about="'.$this->namespace.'">'.$this->LINE_FEED;
		$header .=	'	<rdfs:comment>HaloWiki Export</rdfs:comment>'.$this->LINE_FEED;
		$header .=	'	<rdfs:label>HaloWiki Ontology</rdfs:label>'.$this->LINE_FEED;
		$header .=	'</owl:Ontology>'.$this->LINE_FEED;
		return $header;
 	}
 	
 	private function writeFooter() {
 		$footer = '</rdf:RDF>'.$this->LINE_FEED;
 		return $footer;
 	}
 	
 	/**
 	 * Exports categories
 	 * 
 	 * @param $filehandle handle for a text file.
 	 */
 	private function exportCategories() {
 		// obtain complete number of categories
 		$db =& wfGetDB( DB_SLAVE );
 		
 		$rootCategories = smwfGetSemanticStore()->getCategoriesForInstance($this->page);
 	 		
 		// generate default root concept
 		$owl = '<owl:Class rdf:about="&cat;DefaultRootConcept">'.$this->LINE_FEED;
		$owl .= '	<rdfs:label xml:lang="en">DefaultRootConcept</rdfs:label>'.$this->LINE_FEED;
		$owl .= '</owl:Class>'.$this->LINE_FEED;

 		foreach($rootCategories as $rc) {
 			if (smwfGetSemanticStore()->transitiveCat->equals($rc) 
 					|| smwfGetSemanticStore()->symetricalCat->equals($rc)) {
 						// ignore builtin categories
 						continue;
 			}
 			
 			// export root categories
 			$owl .= '<owl:Class rdf:about="&cat;'.ExportOntologyBot::makeXMLAttributeContent($rc->getDBkey()).'">'.$this->LINE_FEED;
			$owl .= '	<rdfs:label xml:lang="en">'.smwfXMLContentEncode($rc->getText()).'</rdfs:label>'.$this->LINE_FEED;
			$owl .= '	<rdfs:subClassOf rdf:resource="&cat;DefaultRootConcept" />'.$this->LINE_FEED;
 		    // export redirects
            $redirects = smwfGetSemanticStore()->getRedirectPages($rc);
            foreach($redirects as $r) {
                $owl .= "\t".'<owl:equivalentClass rdf:resource="&cat;'.ExportOntologyBot::makeXMLAttributeContent($r->getDBkey()).'"/>'.$this->LINE_FEED;
            }
			$owl .= '</owl:Class>'.$this->LINE_FEED;
			$visitedNodes = array();
			
			$owl .= $this->exportSubcategories($rc, $visitedNodes);
 		}
		return $owl; 		
 	}
 	
 	  	
 	/**
 	 * Exports all instances. 
 	 * Instances without categories will be added to DefaultRootConcept
 	 * 
 	 * @param $filehandle handle for a text file.
 	 */
 	private function exportInstance() {
 					
 		// define member categories. If there is no, put it to DefaultRootConcept by default
 		$categories = smwfGetSemanticStore()->getCategoriesForInstance($this->page);
 		$owl = '<owl:Thing rdf:about="&a;'.ExportOntologyBot::makeXMLAttributeContent($this->page->getDBkey()).'">'.$this->LINE_FEED;
 		if (count($categories) == 0) {
 			$owl .= '	<rdf:type rdf:resource="&cat;DefaultRootConcept"/>'.$this->LINE_FEED;
 		} else {
 			foreach($categories as $category) {
 				$owl .= '	<rdf:type rdf:resource="&cat;'.ExportOntologyBot::makeXMLAttributeContent($category->getDBkey()).'"/>'.$this->LINE_FEED;
 			}
 		}
 		$properties = smwfGetStore()->getProperties($this->page);
 		
 		// export property values (aka annotations)
 		foreach($properties as $p) {
 			// create valid xml export ID for property. If no exists, skip it.
 			$propertyLocal = ExportOntologyBot::makeXMLExportId($p->getDBkey());
 			if ($propertyLocal == NULL) continue;
 			$pDV = SMWPropertyValue::makeUserProperty($p->getDBkey());
 			$values = smwfGetStore()->getPropertyValues($this->page, $pDV);
 			foreach($values as $smwValue) {
 				// export WikiPage value as ObjectProperty
				if ($smwValue instanceof SMWWikiPageValue) {
					$target = $smwValue->getTitle();
																		
						if ($target!=NULL) {
							$owl .= '	<prop:'.$propertyLocal.' rdf:resource="&a;'.ExportOntologyBot::makeXMLAttributeContent($target->getDBkey()).'"/>'.$this->LINE_FEED;
						}
					
	 			} else { // and all others as datatype properties (including n-aries)
	 										
						if ($smwValue->getUnit() != NULL && $smwValue->getUnit() != '') {
							// special handling for units
							$owl .= $this->exportSI($p, $smwValue);
						} else {
		 					$xsdType = $this->mapWikiTypeToXSD[$smwValue->getTypeID()] == NULL ? 'string' : $this->mapWikiTypeToXSD[$smwValue->getTypeID()];
		 					$content = preg_replace("/\x07/","", smwfXMLContentEncode($smwValue->getXSDValue()));
		 					$owl .= '	<prop:'.$propertyLocal.' rdf:datatype="&xsd;'.$xsdType.'">'.$content.'</prop:'.$propertyLocal.'>'.$this->LINE_FEED;
						}
					
	 			}
 			}
 		}
 		// export redirects
 		$redirects = smwfGetSemanticStore()->getRedirectPages($this->page);
 		foreach($redirects as $r) {
 			$owl .= "\t".'<owl:sameAs rdf:resource="&a;'.ExportOntologyBot::makeXMLAttributeContent($r->getDBkey()).'"/>'.$this->LINE_FEED;
 		}
 		
 		$owl .= '</owl:Thing>'.$this->LINE_FEED;
 		return $owl;
	 		
 	}
 	
 	/**
 	 * Exports all properties with their
 	 *  1. Domain and Type/Range (also multiple domains/ranges)
 	 *  2. Cardinality (min/max)
 	 *  3. Symmetry and Transitivity
 	 *  4. Inverse relations
 	 *  5. Super properties
 	 */
 	private function exportProperties() {
 		
 		$properties = smwfGetStore()->getProperties($this->page);
 		
 		$exportetprops = "";
 		
 		foreach($properties as $rp) {
 						
 			if (smwfGetSemanticStore()->domainRangeHintRelation->equals($rp) 
 					|| smwfGetSemanticStore()->minCard->equals($rp) 
 					|| smwfGetSemanticStore()->maxCard->equals($rp)
 					|| smwfGetSemanticStore()->inverseOf->equals($rp)) {
 						// ignore builtin properties
 						continue;
 			}
 			
 			// obtain cardinalities
 			
 			$maxCards = smwfGetStore()->getPropertyValues($rp, smwfGetSemanticStore()->maxCardProp);
 			if ($maxCards != NULL || count($maxCards) > 0) {
 				$maxCard = intval($maxCards[0]->getXSDValue());
 				
 			} else {
 				$maxCard = NULL;
 			}
 			
 			
 			$minCards = smwfGetStore()->getPropertyValues($rp, smwfGetSemanticStore()->minCardProp);
 			if ($minCards != NULL || count($minCards) > 0) {
 				$minCard = intval($minCards[0]->getXSDValue());
 				
 			} else {
 				$minCard = NULL;
 			}
 			
 			// obtain direct super properties
 			$directSuperProperties = smwfGetSemanticStore()->getDirectSuperProperties($rp);
 			
 			// decide what to export by reading property type
 			$hasTypeDV = SMWPropertyValue::makeProperty("_TYPE");
 			$type = smwfGetStore()->getPropertyValues($rp, $hasTypeDV);
 			if ($type == NULL || count($type) == 0) {
 				// default type: binary relation
 				$firstType = '_wpg';
 			} else {
 				$firstType = $type[0]->getXSDValue();
 			}
 			
 			if ($firstType == '_wpg') {
 				// wikipage properties will be exported as ObjectProperties
 				$owl = $this->exportObjectProperty($rp, $directSuperProperties, $maxCard, $minCard);
 			} else { //TODO: how to handle n-aries? for the moment export them as string attributes
 				$owl = $this->exportDatatypeProperty($rp, $firstType, $directSuperProperties, $maxCard, $minCard);
 			}
 			$exportetprops .= $owl;
 		}
 		return $exportetprops;
 	}
 	
 	
 	private function exportSubcategories($superCategory, array & $visitedNodes) {
 		$directSubcategories = smwfGetSemanticStore()->getDirectSubCategories($superCategory);
 		array_push($visitedNodes, $superCategory->getArticleID());
 		$owl = "";
 		foreach($directSubcategories as $c) {
 		
 			if (in_array($c->getArticleID(), $visitedNodes)) {
 				array_pop($visitedNodes);
 				return;
 			}
 			$directSuperCategories = smwfGetSemanticStore()->getDirectSuperCategories($c);
 			
 			$owl .= '<owl:Class rdf:about="&cat;'.ExportOntologyBot::makeXMLAttributeContent($c->getDBkey()).'">'.$this->LINE_FEED;
			$owl .= '	<rdfs:label xml:lang="en">'.smwfXMLContentEncode($c->getText()).'</rdfs:label>'.$this->LINE_FEED;
			foreach($directSuperCategories as $sc) {
				$owl .= '	<rdfs:subClassOf rdf:resource="&cat;'.ExportOntologyBot::makeXMLAttributeContent($sc->getDBkey()).'" />'.$this->LINE_FEED;
			}
 		    // export redirects
            $redirects = smwfGetSemanticStore()->getRedirectPages($c);
            foreach($redirects as $r) {
                $owl .= "\t".'<owl:equivalentClass rdf:resource="&cat;'.ExportOntologyBot::makeXMLAttributeContent($r->getDBkey()).'"/>'.$this->LINE_FEED;
            }
			$owl .= '</owl:Class>'.$this->LINE_FEED;	

			
			// depth-first in category tree
			$this->exportSubcategories($c, $visitedNodes);
 		}
 		array_pop($visitedNodes);
 		return $owl;
 	}
 	
 	
 	
 	private function exportDatatypeProperty($rp, $firstType, $directSuperProperties, $maxCard, $minCard) {
 		$xsdType = $this->mapWikiTypeToXSD[$firstType] == NULL ? 'string' : $this->mapWikiTypeToXSD[$firstType];
 		
 		// export as subproperty 	
		$owl = '<owl:DatatypeProperty rdf:about="&prop;'.ExportOntologyBot::makeXMLAttributeContent($rp->getDBkey()).'">'.$this->LINE_FEED;
		$owl .= '	<rdfs:label xml:lang="en">'.smwfXMLContentEncode($rp->getText()).'</rdfs:label>'.$this->LINE_FEED;
		foreach($directSuperProperties as $dsp) {
 			$owl .= '	<rdfs:subPropertyOf rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($dsp->getDBkey()).'"/>'.$this->LINE_FEED;
 		}
 	    // export redirects
        $redirects = smwfGetSemanticStore()->getRedirectPages($rp);
        foreach($redirects as $r) {
            $owl .= "\t".'<owl:equivalentProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($r->getDBkey()).'"/>'.$this->LINE_FEED;
        }
 		$owl .= '</owl:DatatypeProperty>'.$this->LINE_FEED;
 		
 		// read all domains/ranges
 		
 		$domainRange = smwfGetStore()->getPropertyValues($rp, smwfGetSemanticStore()->domainRangeHintRelation);
 		if ($domainRange == NULL || count($domainRange) == 0) {
 			// if no domainRange annotation exists, export as property of DefaultRootConcept
			$owl .= '	<owl:Class rdf:about="&cat;DefaultRootConcept">'.$this->LINE_FEED;
			$owl .= '		<rdfs:subClassOf>'.$this->LINE_FEED;
			$owl .= '			<owl:Restriction>'.$this->LINE_FEED; 
			$owl .= '				<owl:onProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($rp->getDBkey()).'" />'.$this->LINE_FEED;
			$owl .= '				<owl:allValuesFrom rdf:resource="&xsd;'.$xsdType.'" />'.$this->LINE_FEED;
			$owl .= '			</owl:Restriction>'.$this->LINE_FEED;
			$owl .= '		</rdfs:subClassOf>'.$this->LINE_FEED;
			if ($maxCard != NULL) {
				$owl .= $this->exportMaxCard($rp, $maxCard);
			}
			if ($minCard != NULL) {
				$owl .= $this->exportMinCard($rp, $minCard);
			}
			$owl .= '</owl:Class>'.$this->LINE_FEED;
 		} else {
	 			
	 		foreach($domainRange as $dr) {
		 		$dvs = $dr->getDVs();
		 		$domain = $dvs[0] != NULL ? $dvs[0]->getTitle()->getDBkey() : "";
		 		if ($domain == NULL) continue;
		 		$range = $dvs[1] != NULL ? $dvs[1]->getTitle()->getDBkey() : "";
			
				$owl .= '	<owl:Class rdf:about="&cat;'.ExportOntologyBot::makeXMLAttributeContent($domain).'">'.$this->LINE_FEED;
				$owl .= '		<rdfs:subClassOf>'.$this->LINE_FEED;
				$owl .= '			<owl:Restriction>'.$this->LINE_FEED; 
				$owl .= '				<owl:onProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($rp->getDBkey()).'" />'.$this->LINE_FEED;
				$owl .= '				<owl:allValuesFrom rdf:resource="&xsd;'.$xsdType.'" />'.$this->LINE_FEED;
				$owl .= '			</owl:Restriction>'.$this->LINE_FEED;
				$owl .= '		</rdfs:subClassOf>'.$this->LINE_FEED;
				if ($maxCard != NULL) {
					$owl .= $this->exportMaxCard($rp, $maxCard);
				}
				if ($minCard != NULL) {
					$owl .= $this->exportMinCard($rp, $minCard);
				}
				$owl .= '</owl:Class>'.$this->LINE_FEED;
	 		}
	 				
 		}
		return $owl;
 	}
 	
 	private function exportObjectProperty($rp, $directSuperProperties, $maxCard, $minCard) {
 		        
 				$inverseRelations = smwfGetStore()->getPropertyValues($rp, smwfGetSemanticStore()->inverseOfProp);
 				
 				// export as symmetrical property
 				$owl = '<owl:ObjectProperty rdf:about="&prop;'.ExportOntologyBot::makeXMLAttributeContent($rp->getDBkey()).'">'.$this->LINE_FEED;
 				$owl .= '	<rdfs:label xml:lang="en">'.smwfXMLContentEncode($rp->getText()).'</rdfs:label>'.$this->LINE_FEED;
 				if ($this->checkIfMemberOfCategory($rp, smwfGetSemanticStore()->symetricalCat)) {
 					$owl .= '	<rdf:type rdf:resource="http://www.w3.org/2002/07/owl#SymmetricProperty"/>'.$this->LINE_FEED;
 				}
 				// export as transitive property
 				if ($this->checkIfMemberOfCategory($rp, smwfGetSemanticStore()->transitiveCat)) {
 					$owl .= '	<rdf:type rdf:resource="http://www.w3.org/2002/07/owl#TransitiveProperty"/>'.$this->LINE_FEED;
 				}
 				
 				// export as subproperty
 				foreach($directSuperProperties as $dsp) {
 					$owl .= '	<rdfs:subPropertyOf rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($dsp->getDBkey()).'"/>'.$this->LINE_FEED;
 				}
 				
 				// export as inverse property
 				foreach($inverseRelations as $inv) {
 					if (!($inv instanceof SMWWikiPageValue)) continue;
 					$owl .= '	<owl:inverseOf rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($inv->getTitle()->getDBkey()).'"/>'.$this->LINE_FEED;
 				}
 				
 	            // export redirects
	            $redirects = smwfGetSemanticStore()->getRedirectPages($rp);
	            foreach($redirects as $r) {
	                $owl .= "\t".'<owl:equivalentProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($r->getDBkey()).'"/>'.$this->LINE_FEED;
	            }
 				$owl .= '</owl:ObjectProperty>'.$this->LINE_FEED;
 				
 				$domainRange = smwfGetStore()->getPropertyValues($rp, smwfGetSemanticStore()->domainRangeHintProp);
 				if ($domainRange == NULL || count($domainRange) == 0) {
 					// if no domainRange annotation exists, export as property of DefaultRootConcept
			 				$owl .= '	<owl:Class rdf:about="&cat;DefaultRootConcept">'.$this->LINE_FEED;
			 				$owl .= '		<rdfs:subClassOf>'.$this->LINE_FEED;
			 				$owl .= '			<owl:Restriction>'.$this->LINE_FEED; 
							$owl .= '				<owl:onProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($rp->getDBkey()).'" />'.$this->LINE_FEED;
							$owl .= '               <owl:allValuesFrom rdf:resource="&cat;DefaultRootConcept" />'.$this->LINE_FEED;
							$owl .= '			</owl:Restriction>'.$this->LINE_FEED;
							$owl .= '		</rdfs:subClassOf>'.$this->LINE_FEED;
							if ($maxCard != NULL) {
								$owl .= $this->exportMaxCard($rp, $maxCard);
							}
							if ($minCard != NULL) {
								$owl .= $this->exportMinCard($rp, $minCard);
							}
							$owl .= '</owl:Class>'.$this->LINE_FEED;
 				} else {
	 				
	 				
	 					foreach($domainRange as $dr) {
		 					$dvs = $dr->getDVs();
		 					$domain = $dvs[0] != NULL ? $dvs[0]->getTitle()->getDBkey() : "";
		 					if ($domain == NULL) continue;
		 					$range = $dvs[1] != NULL ? $dvs[1]->getTitle()->getDBkey() : "";
		 				
			 				$owl .= '	<owl:Class rdf:about="&cat;'.ExportOntologyBot::makeXMLAttributeContent($domain).'">'.$this->LINE_FEED;
			 				$owl .= '		<rdfs:subClassOf>'.$this->LINE_FEED;
			 				$owl .= '			<owl:Restriction>'.$this->LINE_FEED; 
							$owl .= '				<owl:onProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($rp->getDBkey()).'" />'.$this->LINE_FEED;
							if ($range != '') $owl .= '				<owl:allValuesFrom rdf:resource="&cat;'.ExportOntologyBot::makeXMLAttributeContent($range).'" />'.$this->LINE_FEED;
							$owl .= '			</owl:Restriction>'.$this->LINE_FEED;
							$owl .= '		</rdfs:subClassOf>'.$this->LINE_FEED;
							if ($maxCard != NULL) {
								$owl .= $this->exportMaxCard($rp, $maxCard);
							}
							if ($minCard != NULL) {
								$owl .= $this->exportMinCard($rp, $minCard);
							}
							$owl .= '</owl:Class>'.$this->LINE_FEED;
	 					}
	 				
 				}
				return $owl;
 	}
 	
 	private function exportMinCard($property, $minCard) {
 		$owl = '		<rdfs:subClassOf>'.$this->LINE_FEED;
		$owl .= '			<owl:Restriction>'.$this->LINE_FEED; 
		$owl .= '				<owl:onProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($property->getDBkey()).'" />'.$this->LINE_FEED;
		$owl .= '				 <owl:minCardinality rdf:datatype="&xsd;nonNegativeInteger">'.$minCard.'</owl:minCardinality>'.$this->LINE_FEED;
		$owl .= '			</owl:Restriction>'.$this->LINE_FEED;
		$owl .= '		</rdfs:subClassOf>'.$this->LINE_FEED;
		return $owl;
 	}
 	
 	private function exportMaxCard($property, $maxCard) {
 		$owl = '		<rdfs:subClassOf>'.$this->LINE_FEED;
		$owl .= '			<owl:Restriction>'.$this->LINE_FEED; 
		$owl .= '				<owl:onProperty rdf:resource="&prop;'.ExportOntologyBot::makeXMLAttributeContent($property->getDBkey()).'" />'.$this->LINE_FEED;
		$owl .= '				 <owl:maxCardinality rdf:datatype="&xsd;nonNegativeInteger">'.$maxCard.'</owl:maxCardinality>'.$this->LINE_FEED;
		$owl .= '			</owl:Restriction>'.$this->LINE_FEED;
		$owl .= '		</rdfs:subClassOf>'.$this->LINE_FEED;
		return $owl;
 	}
 	
 	/**
 	 * Checks if $title is member of $category
 	 */
 	private function checkIfMemberOfCategory($title, $category) {
 		$db =& wfGetDB( DB_SLAVE );
 		$res = $db->selectRow($db->tableName('categorylinks'), 'cl_to', array('cl_from'=>$title->getArticleID(), 'cl_to'=>$category->getDBkey()));
 		return $res !== false;
 	}
 	
 	private function exportSI($pt, $value) {
 		if ( $value->isNumeric() ) {
 			$hasTypeDV = SMWPropertyValue::makeProperty("_TYPE");
 			$conversionFactorSIDV = SMWPropertyValue::makeProperty("___cfsi");
			$dtid = &smwfGetStore()->getPropertyValues($pt, $hasTypeDV);
			$dttitle = Title::newFromText($dtid[0]->getWikiValue(), SMW_NS_TYPE);
			$conv = array();
			if ($dttitle !== NULL)
				$conv = &smwfGetStore()->getPropertyValues($dttitle, $conversionFactorSIDV);
			if ( !empty($conv) ) {
				$dv = SMWDataValueFactory::newPropertyValue($pt->getPrefixedText(), $value->getXSDValue() . " " . $value->getUnit());
					list($sivalue, $siunit) = $this->convertToSI($dv->getNumericValue(), $conv[0]);
					$dv->setUserValue($sivalue . " " . $dv->getUnit()); // in order to translate to XSD
					if ($dv->getXSDValue() != null && $dv->getXSDValue() != '') {
						return "\t\t<prop:" . ExportOntologyBot::makeXMLExportId($pt->getDBkey()) . ' rdf:datatype="&xsd;float">' . 
										smwfXMLContentEncode($dv->getXSDValue()) . 
								'</prop:' . ExportOntologyBot::makeXMLExportId($pt->getDBkey()) . ">\n";
					}

			}
		}
		return '';
 	}
 	
 	// Converts the given value to the SI unit value based, and also
	// returns the name of the unit. Inputs are the value in the standard
	// unit (a float) and the conversion spec string from the corresponds
	// to SI special attribute.
	// This function is only needed for the SI unit export.
	private function convertToSI ($stdvalue, $conversionSpec) {
		$preNum = '';
		$num = null;  // This indicates error.
		$unit = '';
		$decseparator = wfMsgForContent('smw_decseparator');
		$kiloseparator = wfMsgForContent('smw_kiloseparator');

		// First, split off number from the rest.
		// Number is, e.g. -12,347,421.55e6
		// Note the separators might be a magic regexp value like '.', so have to escape them with backslash.
		// This rejects .1 , it needs a leading 0.
		// This rejects - 3, there can't be spaces in the number.
		$arr = preg_split('/([-+]?\d+(?:\\' . $kiloseparator . '\d+)*\\' . $decseparator . '?[\d]*(?:\s*[eE][-+]?\d+)?)[ ]*/', trim($conversionSpec), 2, PREG_SPLIT_DELIM_CAPTURE);

		$arrSiz = count($arr);
		if ($arrSiz >= 1) $preNum = $arr[0];
		if ($arrSiz >= 2) $num = $arr[1];
		if ($arrSiz >= 3) $unit = $arr[2];

		if ($num !== null) {
			// sscanf doesn't like commas or other than '.' for decimal point.
			$num = str_replace($kiloseparator, '', $num);
			if ($decseparator != '.') {
				$num = str_replace($decseparator, '.', $num);
			}
			// sscanf doesn't like space between number and exponent.
			// TODO: couldn't we just delete all ' '? -- mak
			$num = preg_replace('/\s*([eE][-+]?\d+)/', '$1', $num, 1);

			$extra = ''; // required, a failed sscanf leaves it untouched.
			// Run sscanf to convert the number string to an actual float.
			// This also strips any leading + (relevant for LIKE search).
			list($num, $extra) = sscanf($num, "%f%s");

			// junk after the number after parsing indicates syntax error
			// TODO: can this happen? Isn't all junk thrown into $unit anyway? -- mak
			if ($extra != '') {
				$num = null;	// back to error state
			}

			// Clean up leading space from unit, which should be common
			$unit = preg_replace('/^(?:&nbsp;|&thinsp;|\s)+/','', $unit);

			if (is_infinite($num)) {
				return array(0, $unit);
			}
			return array($stdvalue*$num, $unit);
		} else {
			return array(0, '');
		}
	}
	
	
	
	/** 
	 *  This function transforms a string that can be used as an XML-ID. 
	 */
	static function makeXMLExportId($element) {
		// make sure it starts with a letter or underscore (necessary for valid XML)
	    if (preg_match('/^[A-z_].*/', $element) === 0) {
            $element = "_".$element;
        }
        // replace some chars which must not appear in element names
	   $element = str_replace( array('"','#','&',"'",'+','%',')','('),
		                    array('-22','-23','-26','-27','-2B','-','-29','-28'),
		                    $element);
		return preg_match('/^[A-z_][\d\w_-]*$/', $element) > 0 ? $element : NULL;
	}

	/** 
     *  This function transforms a string that can be used as an XML attribute value. 
     * 
     *  @param $attribute value
     *  @param $matchElementID true if value should be escaped same way as element name
     */
	static function makeXMLAttributeContent($attribute, $matchElementID = true) {
		if ($matchElementID) {
			// make sure it starts with a letter or underscore (to match the element names)
			if (preg_match('/^[A-z_].*/', $attribute) === 0) {
				$attribute = "_".$attribute;
			}
			// this chars may appear in attribute values, but they have to match element names
			$attribute = str_replace( array('"','#','&',"'",'+','%',')','('),
	                            array('-22', '-23','-26','-27','-2B','-','-29','-28'),
	                            $attribute);
	        return $attribute;
	        
		} else {
			// " must be escaped in attribute values
			return str_replace( array('"'),
                               array('&quot;'),
                               $attribute);
		}
	}
 	
 }	
?>
